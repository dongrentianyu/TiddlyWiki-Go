import { useState, useEffect } from "react";
import TitleBar from "./components/TitleBar";
import WikiList from "./components/WikiList";
import WikiForm from "./components/WikiForm";
import CreateWikiForm from "./components/CreateWikiForm";
import FilterPanel from "./components/FilterPanel";
import InfoPanel from "./components/InfoPanel";
import PortManager from "./components/PortManager";
import { Wiki } from "./types/wiki";
import {
  GetWikis,
  AddWiki,
  UpdateWiki,
  DeleteWiki,
  StartWiki,
  StopWiki,
  RestartWiki,
  GetWikiStatus,
  GetAllTags,
  GetAllCategories,
  GetAppVersion,
  GetPlatform,
  CheckPortsStatus,
} from "./wailsjs/go/main/App";
import "./App.css";

interface PortInfo {
  port: number;
  inUse: boolean;
  processId: string;
}

type DisplayMode = "all" | "category" | "tag" | "path" | "recent";
type ViewMode = "card" | "list";

function App() {
  const [isDarkMode, setIsDarkMode] = useState(() => {
    const saved = localStorage.getItem("theme");
    return saved === "dark";
  });
  const [wikis, setWikis] = useState<Wiki[]>([]);
  const [filteredWikis, setFilteredWikis] = useState<Wiki[]>([]);
  const [showForm, setShowForm] = useState(false);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [editingWiki, setEditingWiki] = useState<Wiki | null>(null);
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [selectedCategory, setSelectedCategory] = useState<string>("");
  const [searchQuery, setSearchQuery] = useState("");
  const [allTags, setAllTags] = useState<string[]>([]);
  const [allCategories, setAllCategories] = useState<string[]>([]);
  const [showInfo, setShowInfo] = useState(false);
  const [showFilterPage, setShowFilterPage] = useState(false);
  const [showPortManager, setShowPortManager] = useState(false);
  const [displayMode, setDisplayMode] = useState<DisplayMode>("all");
  const [viewMode, setViewMode] = useState<ViewMode>(() => {
    const saved = localStorage.getItem("viewMode");
    return (saved as ViewMode) || "card";
  });
  const [portsInUse, setPortsInUse] = useState<PortInfo[]>([]);

  useEffect(() => {
    loadWikis();
    loadTagsAndCategories();
    checkPorts();

    // Apply theme
    document.documentElement.setAttribute(
      "data-theme",
      isDarkMode ? "dark" : "light"
    );
  }, []);

  useEffect(() => {
    // Update theme
    document.documentElement.setAttribute(
      "data-theme",
      isDarkMode ? "dark" : "light"
    );
    localStorage.setItem("theme", isDarkMode ? "dark" : "light");
  }, [isDarkMode]);

  useEffect(() => {
    localStorage.setItem("viewMode", viewMode);
  }, [viewMode]);

  useEffect(() => {
    filterWikis();
  }, [wikis, selectedTags, selectedCategory, searchQuery, displayMode]);

  const loadWikis = async () => {
    try {
      const data = await GetWikis();
      setWikis(data || []);
    } catch (error) {
      console.error("Failed to load wikis:", error);
    }
  };

  const loadTagsAndCategories = async () => {
    try {
      const tags = await GetAllTags();
      const categories = await GetAllCategories();
      setAllTags(tags || []);
      setAllCategories(categories || []);
    } catch (error) {
      console.error("Failed to load tags and categories:", error);
    }
  };

  const checkPorts = async () => {
    try {
      const ports = await CheckPortsStatus();
      setPortsInUse(ports || []);
    } catch (error) {
      console.error("Failed to check ports:", error);
    }
  };

  const filterWikis = () => {
    let filtered = [...wikis];

    // Search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(
        (wiki) =>
          wiki.name.toLowerCase().includes(query) ||
          wiki.description.toLowerCase().includes(query)
      );
    }

    // Tag filter
    if (selectedTags.length > 0) {
      if (selectedTags.includes("æ— æ ‡ç­¾")) {
        // Include wikis without tags
        const withoutTags = filtered.filter(
          (wiki) => !wiki.tags || wiki.tags.length === 0
        );
        const withTags = filtered.filter((wiki) =>
          selectedTags
            .filter((tag) => tag !== "æ— æ ‡ç­¾")
            .every((tag) => wiki.tags.includes(tag))
        );
        filtered = [...new Set([...withoutTags, ...withTags])];
      } else {
        filtered = filtered.filter((wiki) =>
          selectedTags.every((tag) => wiki.tags.includes(tag))
        );
      }
    }

    // Category filter
    if (selectedCategory) {
      if (selectedCategory === "æ— åˆ†ç±»") {
        filtered = filtered.filter(
          (wiki) => !wiki.category || wiki.category === ""
        );
      } else {
        filtered = filtered.filter(
          (wiki) => wiki.category === selectedCategory
        );
      }
    }

    // Display mode filter
    switch (displayMode) {
      case "recent":
        // Sort by most recently started (updatedAt)
        filtered = filtered.sort(
          (a, b) =>
            new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
        );
        break;
      case "path":
        // Sort by path
        filtered = filtered.sort((a, b) => a.path.localeCompare(b.path));
        break;
      // "all", "category", "tag" use default sorting
      default:
        break;
    }

    setFilteredWikis(filtered);
  };

  const handleAddWiki = async (
    wiki: Omit<Wiki, "id" | "createdAt" | "updatedAt">
  ) => {
    try {
      await AddWiki(wiki as Wiki);
      await loadWikis();
      await loadTagsAndCategories();
      setShowForm(false);
    } catch (error) {
      console.error("Failed to add wiki:", error);
      alert("æ·»åŠ å¤±è´¥ï¼š" + error);
    }
  };

  const handleUpdateWiki = async (wiki: Wiki) => {
    try {
      await UpdateWiki(wiki);
      await loadWikis();
      await loadTagsAndCategories();
      setShowForm(false);
      setEditingWiki(null);
    } catch (error) {
      console.error("Failed to update wiki:", error);
      alert("æ›´æ–°å¤±è´¥ï¼š" + error);
    }
  };

  const handleDeleteWiki = async (id: string) => {
    if (!confirm("ç¡®å®šè¦åˆ é™¤è¿™ä¸ª TiddlyWiki å—ï¼Ÿ")) {
      return;
    }

    try {
      await DeleteWiki(id);
      await loadWikis();
      await loadTagsAndCategories();
    } catch (error) {
      console.error("Failed to delete wiki:", error);
      alert("åˆ é™¤å¤±è´¥ï¼š" + error);
    }
  };

  const handleEditWiki = (wiki: Wiki) => {
    setEditingWiki(wiki);
    setShowForm(true);
  };

  const handleCloseForm = () => {
    setShowForm(false);
    setEditingWiki(null);
  };

  const handleThemeToggle = () => {
    setIsDarkMode(!isDarkMode);
  };

  const wikisWithoutCategory = wikis.filter(
    (w) => !w.category || w.category === ""
  ).length;
  const wikisWithoutTags = wikis.filter(
    (w) => !w.tags || w.tags.length === 0
  ).length;

  return (
    <div className="app">
      <TitleBar
        onThemeToggle={handleThemeToggle}
        isDarkMode={isDarkMode}
      />
      <header className="app-header">
        <div className="header-left">
          <h1>TiddlyWiki Manager</h1>
          <span className="wiki-count">å…± {filteredWikis.length} ä¸ª Wiki</span>
          {portsInUse.filter((p) => p.inUse).length > 0 && (
            <span
              className="ports-warning"
              onClick={() => {
                const inUse = portsInUse.filter((p) => p.inUse);
                const message =
                  "ä»¥ä¸‹ç«¯å£å·²è¢«å ç”¨ï¼š\n\n" +
                  inUse
                    .map(
                      (p) => `ç«¯å£ ${p.port} (PID: ${p.processId || "æœªçŸ¥"})`
                    )
                    .join("\n") +
                  "\n\nç‚¹å‡»ç¡®å®šæŸ¥çœ‹è¯¦æƒ…";
                if (confirm(message)) {
                  inUse.forEach((p) => {
                    if (
                      confirm(
                        `ç«¯å£ ${p.port} å·²è¢«å ç”¨ (PID: ${
                          p.processId || "æœªçŸ¥"
                        })\n\næ˜¯å¦è¦å…³é—­æ­¤è¿›ç¨‹ï¼Ÿ`
                      )
                    ) {
                      handleKillPort(p.port);
                    }
                  });
                }
              }}>
              âš ï¸ {portsInUse.filter((p) => p.inUse).length} ä¸ªç«¯å£è¢«å ç”¨
            </span>
          )}
        </div>
        <div className="header-actions">
          <div className="view-mode-switch">
            <button
              className={`btn-view-mode ${viewMode === "card" ? "active" : ""}`}
              onClick={() => setViewMode("card")}
              title="å¡ç‰‡è§†å›¾">
              â–¦
            </button>
            <button
              className={`btn-view-mode ${viewMode === "list" ? "active" : ""}`}
              onClick={() => setViewMode("list")}
              title="åˆ—è¡¨è§†å›¾">
              â˜°
            </button>
          </div>
          <select
            className="display-mode-select"
            value={displayMode}
            onChange={(e) => setDisplayMode(e.target.value as DisplayMode)}>
            <option value="all">å…¨éƒ¨å±•ç¤º</option>
            <option value="category">æŒ‰åˆ†ç±»</option>
            <option value="tag">æŒ‰æ ‡ç­¾</option>
            <option value="path">æŒ‰è·¯å¾„</option>
            <option value="recent">æœ€è¿‘å¯åŠ¨</option>
          </select>
          <button
            className="btn btn-filter"
            onClick={() => setShowFilterPage(true)}>
            ğŸ” ç­›é€‰
          </button>
          <button
            className="btn btn-info"
            onClick={() => setShowInfo(true)}>
            â„¹ï¸ ä¿¡æ¯
          </button>
          <button
            className="btn btn-success"
            onClick={() => setShowCreateForm(true)}>
            âœ¨ æ–°å»º
          </button>
          <button
            className="btn btn-primary"
            onClick={() => setShowForm(true)}>
            â• æ·»åŠ 
          </button>
        </div>
      </header>

      <div className="app-content">
        <div className="main-content-full">
          <WikiList
            wikis={filteredWikis}
            viewMode={viewMode}
            onEdit={handleEditWiki}
            onDelete={handleDeleteWiki}
            onReload={() => {
              loadWikis();
              checkPorts();
            }}
            onOpenWiki={(wiki) =>
              setViewingWiki({
                url: `http://localhost:${wiki.port}`,
                name: wiki.name,
                path: wiki.path,
              })
            }
            onTagClick={(tag) => {
              setSelectedTags([tag]);
              setShowFilterPage(true);
            }}
            onCategoryClick={(category) => {
              setSelectedCategory(category);
              setShowFilterPage(true);
            }}
          />
        </div>
      </div>

      {showForm && (
        <WikiForm
          wiki={editingWiki}
          onSubmit={editingWiki ? handleUpdateWiki : handleAddWiki}
          onClose={handleCloseForm}
        />
      )}

      {showCreateForm && (
        <CreateWikiForm
          onClose={() => setShowCreateForm(false)}
          onSuccess={() => {
            loadWikis();
            checkPorts();
          }}
        />
      )}

      {viewingWiki && (
        <WikiViewer
          url={viewingWiki.url}
          name={viewingWiki.name}
          path={viewingWiki.path}
          onClose={() => setViewingWiki(null)}
        />
      )}

      {showInfo && (
        <InfoPanel
          wikis={wikis}
          onClose={() => setShowInfo(false)}
        />
      )}

      {showFilterPage && (
        <FilterPanel
          allTags={allTags}
          allCategories={allCategories}
          selectedTags={selectedTags}
          selectedCategory={selectedCategory}
          searchQuery={searchQuery}
          onTagsChange={setSelectedTags}
          onCategoryChange={setSelectedCategory}
          onSearchChange={setSearchQuery}
          onClose={() => setShowFilterPage(false)}
          onApply={() => setShowFilterPage(false)}
          wikisWithoutCategory={wikisWithoutCategory}
          wikisWithoutTags={wikisWithoutTags}
        />
      )}
    </div>
  );
}

export default App;
